//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.0.2-b01-fcs 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2006.08.17 at 04:09:29 PM PDT 
//


package org.flowcyt.facejava.transformation.jaxb;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlType;


/**
 * 
 * 				Logicle transformations
 * 				
 * 				Logicle transformations create a subset of bi-exponential transformation functions 
 * 				that are especially suitable for using in flow cytometry. Thus they can be dimensionized 
 * 				by the a, b, c, d, and f introduced for bi-exponential transformations in general; however, 
 * 				less dimensions is sufficient.  
 * 				
 * 				A logicle transformation function is defined as follows:
 * 				- logical(parameter) = root(S(y, T, w, m) - parameter), where root() is a standard root finding 
 * 				algorithm (e.g., Newton's method) that finds y such that S(y) = parameter.
 * 				
 * 				The S function is defined as follows:
 * 				- if(y = w):		S(y, T, w, m) = Te^(-(m-w)) * (e^(y-w) - p^2 * e^(-(y-w)/p) + p^2 - 1),
 * 				- otherwise:		S(y, T, w, m) = - S(w - y, T, w, m),
 * 				where the dimensions T, w, m and parameter are specified by the T, w, m and parameter attributes of the logicle element. 
 * 				T is the top of scale data value, e.g., 10 000 for common 4 decade data or 262,144 (=218) for an 18 bit data range, 
 * 				w is the width of the negative data range and the range of linearized data in natural logarithm units, w >= 0, 
 * 				m is breadth of the display in natural logarithm units, e.g., for a 4.5 decade display range m = 4.5*ln(10) = 10.3616329 
 * 				
 * 				p is introduced for compactness; it and w together represent a single adjustable transformation parameter, 
 * 				w = 2p*ln(p)/(p+1). 
 * 				For w >= 0, the function is continuous and has a derivative, so p can be found using bisection method or even 
 * 				faster using Newton's method.
 * 				
 * 				e is the base of the natural logarithm, i.e., e = 2.71828 18284 59045 23536 02874 7135... 
 * 			
 * 
 * <p>Java class for Logicle complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="Logicle">
 *   &lt;complexContent>
 *     &lt;extension base="{http://www.isac-net.org/std/Transformation-ML/v1.0/}AbstractPredefinedTransformation">
 *       &lt;attribute name="T" use="required" type="{http://www.isac-net.org/std/common-types/v1.0/}PositiveDouble" />
 *       &lt;attribute name="m" use="required" type="{http://www.isac-net.org/std/common-types/v1.0/}PositiveDouble" />
 *       &lt;attribute name="w" use="required" type="{http://www.isac-net.org/std/common-types/v1.0/}NonNegativeDouble" />
 *     &lt;/extension>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "Logicle", namespace = "http://www.isac-net.org/std/Transformation-ML/v1.0/")
public class Logicle
    extends AbstractPredefinedTransformation
{

    @XmlAttribute(name = "T", namespace = "http://www.isac-net.org/std/Transformation-ML/v1.0/", required = true)
    protected double t;
    @XmlAttribute(namespace = "http://www.isac-net.org/std/Transformation-ML/v1.0/", required = true)
    protected double m;
    @XmlAttribute(namespace = "http://www.isac-net.org/std/Transformation-ML/v1.0/", required = true)
    protected double w;

    /**
     * Gets the value of the t property.
     * 
     */
    public double getT() {
        return t;
    }

    /**
     * Sets the value of the t property.
     * 
     */
    public void setT(double value) {
        this.t = value;
    }

    /**
     * Gets the value of the m property.
     * 
     */
    public double getM() {
        return m;
    }

    /**
     * Sets the value of the m property.
     * 
     */
    public void setM(double value) {
        this.m = value;
    }

    /**
     * Gets the value of the w property.
     * 
     */
    public double getW() {
        return w;
    }

    /**
     * Sets the value of the w property.
     * 
     */
    public void setW(double value) {
        this.w = value;
    }

}
