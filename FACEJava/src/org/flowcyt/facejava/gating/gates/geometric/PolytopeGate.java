package org.flowcyt.facejava.gating.gates.geometric;

import java.util.Collections;
import java.util.List;
import java.util.Set;

import org.flowcyt.facejava.fcsdata.DataRetriever;
import org.flowcyt.facejava.fcsdata.Event;
import org.flowcyt.facejava.fcsdata.ParameterReference;
import org.flowcyt.facejava.fcsdata.Population;
import org.flowcyt.facejava.fcsdata.exception.DataRetrievalException;
import org.flowcyt.facejava.gating.exception.InvalidGateDescriptionException;
import org.flowcyt.facejava.gating.gates.Gate;
import org.flowcyt.facejava.gating.gates.GateSubPopulation;
import org.flowcyt.facejava.gating.gates.geometric.GeometricGate;
import org.flowcyt.facejava.gating.jaxb.Point;

/**
 * <p>
 * Represents a polytope gate. An event is inside if it is inside the convex hull of
 * the polytope generated by the given points (where only the data in the given dimensions
 * are considered).
 * 
 * <p>
 * PolytopeGate will use different implementations to perform the actual event
 * testing because performance gains can be realized by doing so (over just using the
 * n-dimension tester for everything). See the different implementations of
 * PolytopeGateTester for details of how they compute inside-ness.
 * 
 * @author sli (original author), echng (heavily modified)
 */
public class PolytopeGate extends GeometricGate{
	
	/**
	 * The tester to use for this PolytopeGate (based on how many dimensions the gate
	 * has.)
	 */
	private PolytopeGateTester tester;
	
	private List<Point> pointList;
	
	/**
	 * Creates a PolytopeGate object.
	 * @param gateId The gate's id.
	 * @param dimList The gate's dimensions.
	 * @param pointList The points in the polytope.
	 * @throws InvalidGateDescriptionException Thrown if there is one point which
	 * does not have the same number of coordinates as there are dimensions.
	 */
	public PolytopeGate(String gateId, List<ParameterReference> dimList, List<Point> pointList) throws InvalidGateDescriptionException {
		super(gateId, dimList);
		
		this.pointList = pointList;
		
		validate();
		
		// Create the appropriate PolytopeGateTester.
		if (dimList.size() == 1) {
			tester = new OneDimensionPolytopeTester(this, pointList);
		} else if (dimList.size() == 2) {
			tester = new TwoDimensionPolytopeTester(this, pointList);
		} else {
			tester = new NDimensionPolytopeTester(this, pointList);
		}
	}
	
	public void validate() throws InvalidGateDescriptionException {
		for (Point pt : pointList) {
			if (pt.getCoordinate().size() != dimensions.size())
				throw new InvalidGateDescriptionException(this.getId(),
					"Polytope Points must have the same number of coordinates as dimensions");
		}
	}
	
	public Set<Gate> getDirectDependencies() {
		return Collections.emptySet();
	}
	
	public GateSubPopulation isInside(Population population, DataRetriever retriever) throws DataRetrievalException {
		// The N-Dimension tester overrides this for huge performance gains so we can
		// just punt all calls to the tester (since the other testers just do the 
		// basics of testing each Event)
		return tester.isInside(population, retriever);	
	}

	public boolean isInside(Event ev, DataRetriever retriever) throws DataRetrievalException {
		return tester.isInside(ev, retriever);
	}
	
	public String toString() {
		return "Polytope " + super.toString() + "\n" + tester.toString();
	}
}
